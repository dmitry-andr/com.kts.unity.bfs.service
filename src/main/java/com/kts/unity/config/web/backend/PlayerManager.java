package com.kts.unity.config.web.backend;

import com.kts.facebookapp.dtos.DataForExperienceDTO;
import com.kts.unity.config.gamification.GamificationPlugin;
import com.kts.unity.config.gamification.common.ScoresRankingEntry;
import com.kts.unity.config.web.backend.dao.FacebookIdentityDAO;
import com.kts.unity.config.web.backend.dao.PlayerDAO;
import com.kts.unity.config.web.backend.dao.PlayerGameProfileDAO;
import com.kts.unity.config.web.backend.dao.PlayerGameStatisticsDAO;
import com.kts.unity.config.web.backend.dao.PurchaseTransactionDAO;
import com.kts.unity.config.web.backend.dao.SecCodeDAO;
import com.kts.unity.config.web.backend.utils.BreakingScoringRulesException;
import com.kts.unity.config.web.backend.utils.PasswordGenerator;
import com.kts.unity.config.web.backend.utils.player.PlayerLevelsProgressUtility;
import com.kts.unity.config.web.backend.utils.ScoringRules;
import com.kts.unity.config.web.backend.utils.Settings;
import com.kts.unity.config.web.backend.utils.purchase.PurchaseUtils;
import com.kts.unity.config.web.entities.player.Player;
import com.kts.unity.config.web.entities.SecCode;
import com.kts.unity.config.web.utils.ConfigParams;
import com.kts.unity.config.web.backend.utils.UCID;
import com.kts.unity.config.web.entities.configs.Configuration;
import com.kts.unity.config.web.entities.LevelsProgress;
import com.kts.unity.config.web.entities.PurchaseTransactionData;
import com.kts.unity.config.web.entities.configs.Achievement;
import com.kts.unity.config.web.entities.configs.AchievementsConfiguration;
import com.kts.unity.config.web.entities.player.PlayerGameProfile;
import com.kts.unity.config.web.entities.player.PlayerGameStatistics;
import com.kts.unity.config.web.entities.player.PlayerWithGameProfAndStatisticsAndChallengeData;
import com.kts.unity.config.web.entities.configs.RocketConfigEntry;
import com.kts.unity.config.web.entities.configs.RocketsConfiguration;
import com.kts.unity.config.web.entities.configs.WeaponConfiguration;
import com.kts.unity.config.web.entities.configs.WeaponEntry;
import com.kts.unity.config.web.entities.player.PlayerOnlineData;
import com.kts.unity.config.web.entities.player.PlayerWithPurchaseData;
import com.kts.unity.config.web.utils.AppContext;
import com.kts.unity.config.web.utils.AppSpringBeans;
import com.restfb.types.User;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

public class PlayerManager {

    private PlayerDAO playerDAO;
    private SecCodeDAO secCodeDAO;
    private PlayerGameProfileDAO playerGameProfileDAO;
    private PlayerGameStatisticsDAO playerGameStatisticsDAO;
    private FacebookIdentityDAO facebookIdentityDAO;
    private PurchaseTransactionDAO purchaseTransactionDAO;

    public int createPlayer(Player player, String facebookId) {
        int status = 0;

        try {
            Player playerInBD = this.getPlayerByName(player.getName());
            if (playerInBD != null) {
                return 2;//Player with such name already exists                
            }

            if (player.getName() != null) {
                if ((player.getName().length() == 0) || (player.getName().length() > ConfigParams.PLAYER_NAME_LENGTH_MAX)) {
                    return 3;//name empty or longer than 50 symbols                
                }
            } else {
                return 3;
            }

            /*
            if (player.getEmail() != null) {
            if ((player.getEmail().length() == 0) || (player.getEmail().length() > ConfigParams.PLAYER_EMAIL_LENGTH_MAX)) {
            return 4;//email empty or longer than 50 symbols
            }
            } else {
            return 4;
            }
             */

            if ((player.getPassword() == null) || ("".equals(player.getPassword()))) {
                player.setPassword((new PasswordGenerator()).getNewAutoGeneratedPassword(ConfigParams.AUTO_GENERATED_PASSWORD_LENGTH));
            }


            status = playerDAO.createPlayer(player);//if player was saved successully status code 1 returned

            int createdPlayerId = (playerDAO.getPlayerByName(player.getName())).getId();

            if ((facebookId != null) && (!"".equals(facebookId))) {
                facebookIdentityDAO.createFbIdentity(createdPlayerId, facebookId);
            }
        } catch (Exception ex) {
            status = 5;
            ex.printStackTrace();
        }

        return status;
    }

    public int removePlayerWithProfileAndData(int playerId) {
        int status = 0;

        status = this.secCodeDAO.removeSecCodeForPlayer(playerId);
        status = status + (status - 1);

        status = this.playerGameStatisticsDAO.deletePlayerGameStatistics(playerId);
        status = status + (status - 1);

        status = this.playerGameProfileDAO.deletePlayerGameProfile(playerId);
        status = status + (status - 1);

        status = this.facebookIdentityDAO.removeFbIdentity(playerId);
        status = status + (status - 1);

        status = this.playerDAO.deletePlayer(playerId);
        status = status + (status - 1);

        status = this.playerDAO.deletePlayerLevelProgressRecord(playerId);
        status = status + (status - 1);

        status = GamificationPlugin.removeChallengesDataForPlayer(playerId);
        status = status + (status - 1);


        return status;
    }

    public int updatePlayerProfile(Player player) {
        int status = 0;

        try {
            if (player.getName() != null) {
                if ((player.getName().length() == 0) || (player.getName().length() > ConfigParams.PLAYER_NAME_LENGTH_MAX)) {
                    return 3;//name empty or longer than 50 symbols                
                }
            } else {
                return 3;
            }

            status = playerDAO.updatePlayer(player);//if player was updated successully status code 1 returned
        } catch (Exception ex) {
            status = 5;
            ex.printStackTrace();
        }

        return status;
    }

    public Player getPlayerByName(String playerName) {
        try {
            return this.playerDAO.getPlayerByName(playerName);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public Player getPlayerById(int playerId) {
        try {
            return this.playerDAO.getPlayerById(playerId);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public String authenticatePlayerByPassword(String playerName, String playerPassword, int permanent) {
        //validate input parameters
        if ((playerName == null) || (playerPassword == null)) {
            return ConfigParams.AUTH_PARAMS_INVALID;//invalid params
        }
        if ((playerName.length() == 0) || (playerPassword.length() == 0)) {
            return ConfigParams.AUTH_PARAMS_INVALID;//invalid params
        }
        //end validation

        try {
            Player player = this.playerDAO.getPlayerByName(playerName);
            if(player == null){
                return ConfigParams.USER_DOES_NOT_EXIST_WS;
            }
            if (playerPassword.equals(player.getPassword())) {
                //if user already has sec code delete it from table before generating the new one
                SecCode secCode = null;
                secCode = this.secCodeDAO.getSecCodeForPlayer(player.getId());
                if (secCode != null) {
                    this.secCodeDAO.removeSecCodeForPlayer(player.getId());
                } else {
                    secCode = new SecCode();
                    secCode.setPlayerId(player.getId());
                }

                UCID secCodeGen = new UCID();
                secCode.setSecCode(secCodeGen.toString());
                //if permanent flag is not 1 - what means save code as permanent than set val to 0
                if (permanent != 1) {
                    permanent = 0;
                } else {
                    permanent = 1;
                }
                secCode.setPermanent(permanent);
                int saveSecCodeOperStatus = 0;
                saveSecCodeOperStatus = this.secCodeDAO.saveSecCodeForPlayer(secCode);
                if (saveSecCodeOperStatus == 1) {
                    return secCode.getSecCode();
                }
            } else {
                return ConfigParams.USER_PASSW_AUTH_FAILED_WS;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ConfigParams.SERVER_APP_ERROR_WS;
    }

    public String authenticatePlayerByEmail(String playerName, String playerEmail, int permanent) {

        //validate input parameters
        if ((playerName == null) || (playerEmail == null)) {
            return ConfigParams.AUTH_PARAMS_INVALID;//invalid params
        }
        if ((playerName.length() == 0) || (playerEmail.length() == 0)) {
            return ConfigParams.AUTH_PARAMS_INVALID;//invalid params
        }
        //end validation

        try {
            Player player = this.playerDAO.getPlayerByName(playerName);
            if ((player != null) && playerEmail.equals(player.getEmail())) {
                //if user already has sec code delete it from table before generating the new one
                SecCode secCode;
                secCode = this.secCodeDAO.getSecCodeForPlayer(player.getId());
                if (secCode != null) {
                    this.secCodeDAO.removeSecCodeForPlayer(player.getId());
                } else {
                    secCode = new SecCode();
                    secCode.setPlayerId(player.getId());
                }

                UCID secCodeGen = new UCID();
                secCode.setSecCode(secCodeGen.toString());
                //if permanent flag is not 1 - what means save code as permanent than set val to 0
                if (permanent != 1) {
                    permanent = 0;
                } else {
                    permanent = 1;
                }
                secCode.setPermanent(permanent);
                int saveSecCodeOperStatus = 0;
                saveSecCodeOperStatus = this.secCodeDAO.saveSecCodeForPlayer(secCode);
                if (saveSecCodeOperStatus == 1) {
                    return secCode.getSecCode();
                }
            } else {
                return ConfigParams.USER_PASSW_AUTH_FAILED_WS;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ConfigParams.SERVER_APP_ERROR_WS;
    }

    public String authenticatePlayerByFbId(String playerName, String facebookId, int permanent) {

        //validate input parameters
        if ((playerName == null) || (facebookId == null)) {
            return ConfigParams.AUTH_PARAMS_INVALID;//invalid params
        }
        if ((playerName.length() == 0) || (facebookId.length() == 0)) {
            return ConfigParams.AUTH_PARAMS_INVALID;//invalid params
        }
        //end validation

        try {
            Player player = this.playerDAO.getPlayerByName(playerName);
            if (player == null) {
                return ConfigParams.USER_PASSW_AUTH_FAILED_WS;
            }
            String facebookIdInSystem = this.facebookIdentityDAO.getFbIdForPlayer(player.getId());

            if (facebookId.equals(facebookIdInSystem)) {
                //if user already has sec code delete it from table before generating the new one
                SecCode secCode = null;
                secCode = this.secCodeDAO.getSecCodeForPlayer(player.getId());
                if (secCode != null) {
                    this.secCodeDAO.removeSecCodeForPlayer(player.getId());
                } else {
                    secCode = new SecCode();
                    secCode.setPlayerId(player.getId());
                }

                UCID secCodeGen = new UCID();
                secCode.setSecCode(secCodeGen.toString());
                //if permanent flag is not 1 - what means save code as permanent than set val to 0
                if (permanent != 1) {
                    permanent = 0;
                } else {
                    permanent = 1;
                }
                secCode.setPermanent(permanent);
                int saveSecCodeOperStatus = 0;
                saveSecCodeOperStatus = this.secCodeDAO.saveSecCodeForPlayer(secCode);
                if (saveSecCodeOperStatus == 1) {
                    return secCode.getSecCode();
                }
            } else {
                return ConfigParams.USER_PASSW_AUTH_FAILED_WS;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ConfigParams.SERVER_APP_ERROR_WS;
    }

    public int authenticatePlayerBySecCode(String playerName, String securityCode) {
        int status = 0;
        //validate input parameters
        if ((playerName == null) || (securityCode == null)) {
            return 4;//Empty playerName or securityCode passed
        }
        if ((playerName.length() == 0) || (securityCode.length() == 0)) {
            return 4;//Empty playerName or securityCode passed
        }
        //end validation

        try {
            Player player = this.playerDAO.getPlayerByName(playerName);
            if (player != null) {
                SecCode secCode = this.secCodeDAO.getSecCodeForPlayer(player.getId());
                if ((secCode != null) && (secCode.getPermanent() == 1)) {
                    if (securityCode.equals(secCode.getSecCode())) {
                        return 1;//player authenticated by sec code
                    } else {
                        return 3;//User exists but has to relogin as security code is obsolete or user has no sec code yet
                    }
                } else {
                    return 3;
                }
            } else {
                return 3;//no user with such login name
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return status;
    }

    public Integer getPlayerIDBySecCode(String secCode) {
        try {
            return this.secCodeDAO.getPlayerIDForSecCode(secCode);
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }

    public int createPlayerGameProfile(PlayerGameProfile playerProfile) {
        int status = 0;

        try {
            status = this.playerGameProfileDAO.createPlayerProfile(playerProfile);
            status = this.playerGameStatisticsDAO.createPLayerGameStatisticsRecord(playerProfile.getProfileId());
        } catch (Exception ex) {
            status = 0;
            ex.printStackTrace();
        }

        return status;
    }

    public int updatePlayerGameProfile(PlayerGameProfile playerProfile) {
        int status = 0;

        try {
            status = this.playerGameProfileDAO.updatePlayerGameProfile(playerProfile);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return status;
    }

    public int getNumberOfPlayersInSystem() {
        return this.playerDAO.getNumberOfPlayersInSystem();
    }

    public int getNumberOfTransactions() {
        return this.purchaseTransactionDAO.getNumberOfTransactions();
    }

    public int updatePlayerOnlineStatus(String playerName) {
        Player playerInSystem = this.playerDAO.getPlayerByName(playerName);
        if (playerInSystem != null) {
            long currentTimeMillis = (new Date()).getTime();
            PlayerOnlineData onlineData = new PlayerOnlineData();
            onlineData.setPlayerId(playerInSystem.getId());
            onlineData.setLastActivityTime(currentTimeMillis);
            if (this.playerDAO.isPlayerOnline(playerInSystem.getId())) {
                this.playerDAO.updatePlayerOnlineData(onlineData);
            } else {
                this.playerDAO.createPlayerOnlineRecord(onlineData);
            }

            return 1;
        }

        return 0;
    }

    public Map<Integer, PlayerOnlineData> getOnlinePlayers() {
        return this.playerDAO.getPlayersOnline();
    }

    public PlayerGameProfile getPlayerGameProfile(String playerName) {

        PlayerGameProfile playerGameProfile = null;
        try {
            Player player = this.getPlayerByName(playerName);
            if (player != null) {
                playerGameProfile = this.playerGameProfileDAO.getPlayerGameProfile(player.getId());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return playerGameProfile;
    }

    public PlayerGameProfile getPlayerGameProfileById(int playerId) {
        return this.playerGameProfileDAO.getPlayerGameProfile(playerId);
    }

    public int updatePlayersScoresAndExperience(String killerName, String killedName, int playersNumber, int leftPlayersNumber, DataForExperienceDTO experienceData) {
        int status = 0;
        try {
            Player playerWon = this.playerDAO.getPlayerByName(killerName);
            Player playerLost = this.playerDAO.getPlayerByName(killedName);
            PlayerGameProfile playerWonGameProfile = this.playerGameProfileDAO.getPlayerGameProfile(playerWon.getId());
            PlayerGameProfile playerLostGameProfile = this.playerGameProfileDAO.getPlayerGameProfile(playerLost.getId());

            ScoringRules rules = (ScoringRules) AppContext.getContext().getBean(AppSpringBeans.SCORING_RULES_BEAN);
            int scores = rules.getScores(playerWonGameProfile.getRank(), playerLostGameProfile.getRank());

            if (!Settings.getBotsNames().contains(playerWon.getName())) {
                playerWonGameProfile.setScores(playerWonGameProfile.getScores() + scores);
                int playerWonRankAfterGame = rules.getRankForPoints(playerWonGameProfile.getScores());
                if (playerWonRankAfterGame > 0) {
                    playerWonGameProfile.setRank(playerWonRankAfterGame);
                } else {
                    throw new BreakingScoringRulesException("Rules cannot be applied to scores provided !!!");
                }
            }

            if (leftPlayersNumber == 1) {//no other players left - update experience points for killer
                playerWonGameProfile.setExperiencePoints(playerWonGameProfile.getExperiencePoints() + this.calculateExperiencePoints(false, scores, playerWonGameProfile, experienceData));
            }


            //do not allow to set negative scores to player and add points to slow down points loss
            int lostPointsCompensation = 5;
            if (!Settings.getBotsNames().contains(playerLost.getName())) {
                if ((playerLostGameProfile.getScores() - scores + lostPointsCompensation) >= 0) {
                    playerLostGameProfile.setScores(playerLostGameProfile.getScores() - scores + lostPointsCompensation);
                } else {
                    playerLostGameProfile.setScores(0);
                }
                int playerLostRankAfterGame = rules.getRankForPoints(playerLostGameProfile.getScores());
                if (playerLostRankAfterGame > 0) {
                    playerLostGameProfile.setRank(playerLostRankAfterGame);

                    //check if player still allowed to use current ship after he/she lost the game
                    RocketConfigEntry lostPlayerRocketConfig = RocketsConfiguration.getInstance().rocketConfigForRocketId(String.valueOf(playerLostGameProfile.getShipType()));
                    for (int k = 0; k < 10; k++) {
                        if ((playerLostGameProfile.getRank() >= Integer.parseInt(lostPlayerRocketConfig.getRank()))
                                || (PurchaseUtils.isItemBought(playerLostGameProfile.getShipType(), playerLostGameProfile.getPuchasedItemsList()))) {

                            break;
                        } else {
                            String decreasedRocketConfigId = String.valueOf(Integer.parseInt(lostPlayerRocketConfig.getId()) - 1);
                            lostPlayerRocketConfig = RocketsConfiguration.getInstance().rocketConfigForRocketId(decreasedRocketConfigId);
                            playerLostGameProfile.setShipType(Integer.parseInt(lostPlayerRocketConfig.getId()));
                        }
                    }


                    //check if player still allowed to use current weapon after he/she lost the game
                    WeaponEntry lostPlayerWeaponConfig = WeaponConfiguration.getInstance().weaponEntryForId(playerLostGameProfile.getWeaponId());
                    for (int j = 0; j < 10; j++) {
                        if ((playerLostGameProfile.getRank() >= Integer.parseInt(lostPlayerWeaponConfig.getMinrank()))
                                || (PurchaseUtils.isItemBought(playerLostGameProfile.getWeaponId(), playerLostGameProfile.getPuchasedItemsList()))) {

                            break;
                        } else {
                            int decreasedWeaponConfigId = Integer.parseInt(lostPlayerWeaponConfig.getId()) - 1;
                            lostPlayerWeaponConfig = WeaponConfiguration.getInstance().weaponEntryForId(decreasedWeaponConfigId);
                            playerLostGameProfile.setWeaponId(Integer.parseInt(lostPlayerWeaponConfig.getId()));
                        }
                    }
                } else {
                    throw new BreakingScoringRulesException("Rules cannot be applied to the scores provided !!!");
                }
            }

            playerLostGameProfile.setExperiencePoints(playerLostGameProfile.getExperiencePoints() + this.calculateExperiencePoints(true, 0, playerLostGameProfile, experienceData));


            //update players positions in challenges/ranking charts
            if ((!playerWon.getName().equals(ConfigParams.ADMIN_RESERVED_SERVICE_NAME)) && (!Settings.getBotsNames().contains(playerWon.getName()))) {
                GamificationPlugin.updateDayScoresForPlayer(playerWonGameProfile.getProfileId(), scores);
                GamificationPlugin.updateWeekScoresForPlayer(playerWonGameProfile.getProfileId(), scores);
                GamificationPlugin.updateTournamentScoresForPlayer(playerWonGameProfile.getProfileId(), scores);
                int shootingAccuracy = 0;
                if (experienceData.getKillerShots() != 0) {
                    shootingAccuracy = (int) Math.round(experienceData.getKillerHits() * 100.0f / experienceData.getKillerShots());
                }
                GamificationPlugin.updateSniperScoresForPlayer(playerWonGameProfile.getProfileId(), shootingAccuracy);
            }
            if ((!playerLost.getName().equals(ConfigParams.ADMIN_RESERVED_SERVICE_NAME)) && (!Settings.getBotsNames().contains(playerLost.getName()))) {
                GamificationPlugin.updateDayScoresForPlayer(playerLostGameProfile.getProfileId(), GamificationPlugin.POINS_TO_ADD_FOR_LOST_PLAYER);
                GamificationPlugin.updateWeekScoresForPlayer(playerLostGameProfile.getProfileId(), GamificationPlugin.POINS_TO_ADD_FOR_LOST_PLAYER);
                GamificationPlugin.updateTournamentScoresForPlayer(playerLostGameProfile.getProfileId(), GamificationPlugin.POINS_TO_ADD_FOR_LOST_PLAYER);
                int shootingAccuracy = 0;
                if (experienceData.getPlayerShots() != 0) {
                    shootingAccuracy = (int) Math.round(experienceData.getPlayerHits() * 100.0f / experienceData.getPlayerShots());
                }
                GamificationPlugin.updateSniperScoresForPlayer(playerLostGameProfile.getProfileId(), shootingAccuracy);
            }




            //update player statistics
            PlayerGameStatistics playerWonGameStat = this.playerGameStatisticsDAO.getPlayerGameStatistics(playerWon.getId());
            int killedCount = playerWonGameStat.getKilledrank()[playerLostGameProfile.getRank() - 1];
            killedCount++;
            playerWonGameStat.getKilledrank()[playerLostGameProfile.getRank() - 1] = killedCount;
            status = this.playerGameStatisticsDAO.updatePlayerGameStatistics(playerWonGameStat);

            PlayerGameStatistics playerLostGameStat = this.playerGameStatisticsDAO.getPlayerGameStatistics(playerLost.getId());
            int killedByCount = playerLostGameStat.getKilledbyrank()[playerWonGameProfile.getRank() - 1];
            killedByCount++;
            playerLostGameStat.getKilledbyrank()[playerWonGameProfile.getRank() - 1] = killedByCount;
            status = this.playerGameStatisticsDAO.updatePlayerGameStatistics(playerLostGameStat);


            //Update player achievements here
            playerWonGameProfile.setAchievementsList(this.checkAndUpdateAchievements(killerName, playerWonGameProfile, playerWonGameStat));
            playerLostGameProfile.setAchievementsList(this.checkAndUpdateAchievements(killedName, playerLostGameProfile, playerLostGameStat));

            status = this.playerGameProfileDAO.updatePlayerGameProfile(playerWonGameProfile);
            status = this.playerGameProfileDAO.updatePlayerGameProfile(playerLostGameProfile);
        } catch (Exception ex) {
            status = 0;
            ex.printStackTrace();
        }

        return status;
    }

    private String checkAndUpdateAchievements(String playerName, PlayerGameProfile gameProfile, PlayerGameStatistics gameStat) {

        String achievments = gameProfile.getAchievementsList();


        int numOfEnemiesDestroyed = 0;
        for (int k = 0; k < gameStat.getKilledrank().length; k++) {
            numOfEnemiesDestroyed = numOfEnemiesDestroyed + gameStat.getKilledrank()[k];
        }

        //Achievement - 401 - First enemy destroyed
        String achievementId = "401";
        Achievement achmnt = AchievementsConfiguration.getInstance().getAchievementForId(achievementId);
        if (numOfEnemiesDestroyed >= 1) {
            if (achievments != null) {
                if (!achievments.contains(achievementId)) {
                    achievments += ";" + achievementId;
                    gameProfile.setExperiencePoints(gameProfile.getExperiencePoints() + achmnt.getPoints());
                    gameProfile.setCoinsBalance(gameProfile.getCoinsBalance() + achmnt.getAwardingCoins());
                }
            } else {
                achievments = achievementId;
                gameProfile.setExperiencePoints(gameProfile.getExperiencePoints() + achmnt.getPoints());
                gameProfile.setCoinsBalance(gameProfile.getCoinsBalance() + achmnt.getAwardingCoins());
            }
        }

        //Achievement - 402 - 5 enemies destroyed
        achievementId = "402";
        achmnt = AchievementsConfiguration.getInstance().getAchievementForId(achievementId);
        if (numOfEnemiesDestroyed >= 5) {
            if (achievments != null) {
                if (!achievments.contains(achievementId)) {
                    achievments += ";" + achievementId;
                    gameProfile.setExperiencePoints(gameProfile.getExperiencePoints() + achmnt.getPoints());
                    gameProfile.setCoinsBalance(gameProfile.getCoinsBalance() + achmnt.getAwardingCoins());
                }
            } else {
                achievments = achievementId;
                gameProfile.setExperiencePoints(gameProfile.getExperiencePoints() + achmnt.getPoints());
                gameProfile.setCoinsBalance(gameProfile.getCoinsBalance() + achmnt.getAwardingCoins());
            }
        }


        return achievments;
    }

    private int calculateExperiencePoints(boolean updatePintsForLoser, int addedScores, PlayerGameProfile profile, DataForExperienceDTO experienceData) {
        float points = 0.0f;

        int sharpshootingConstMultiplyer = Integer.parseInt((Configuration.getInstance().getEntryFromMap(Configuration.SHARP_SHOOTING_CONST)).getValue());
        int damageConstMultiplyer = Integer.parseInt((Configuration.getInstance().getEntryFromMap(Configuration.DAMAGE_CONST)).getValue());
        int scoresConstMultiplyer = Integer.parseInt((Configuration.getInstance().getEntryFromMap(Configuration.SCORES_CONST_COEFFICENT)).getValue());

        if (updatePintsForLoser) {
            if (experienceData.getPlayerShots() > 0) {
                points += (experienceData.getPlayerHits() * 1.0f / experienceData.getPlayerShots()) * sharpshootingConstMultiplyer;
            }
            if (experienceData.getPlayerDamage() > 0) {
                points += (1 / (experienceData.getPlayerDamage() + 1)) * damageConstMultiplyer;
            }
        } else {
            if (experienceData.getKillerShots() > 0) {
                points += (experienceData.getKillerHits() * 1.0f / experienceData.getKillerShots()) * sharpshootingConstMultiplyer;
            }
            if (experienceData.getPlayerDamage() > 0) {
                points += (1 / experienceData.getPlayerDamage()) * damageConstMultiplyer;
            }

            points += addedScores * scoresConstMultiplyer;
        }

        return (int) Math.round(points);
    }

    public PlayerGameStatistics getPlayerGameStatistics(String playerName) {

        PlayerGameStatistics playerGameStatistics = null;
        try {
            Player player = this.getPlayerByName(playerName);
            if (player != null) {
                playerGameStatistics = this.playerGameStatisticsDAO.getPlayerGameStatistics(player.getId());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return playerGameStatistics;
    }

    public int getPlayerRankPositionInSinglePlayerMode(int playerId) {
        int position = -1;
        position = this.playerDAO.getPlayerPositionBySinglePlayerRanking(playerId);

        return position;
    }

    public int updatePlayerLevelProgress(int playerId, int levelCompleted, int progressCompletedPercents) {
        int status = 0;
        Player player;
        LevelsProgress levelProgressData;
        try {
            player = this.playerDAO.getPlayerById(playerId);
            levelProgressData = this.playerDAO.getPlayerLevelProgress(playerId);
            if (levelProgressData == null) {
                PlayerLevelsProgressUtility levelProgressUtil = new PlayerLevelsProgressUtility(player.getName(), levelCompleted, progressCompletedPercents);
                levelProgressData = new LevelsProgress();
                levelProgressData.setPlayerId(playerId);
                levelProgressData.setLevelsProgressData(levelProgressUtil.getLevelsData());
                levelProgressData.setLevelsProgressRankingPoints(levelProgressUtil.getProgressPoinsInSinglePlayerMode());
                status = this.playerDAO.createPlayerLevelProgressRecord(levelProgressData);
                return status;
            }

            PlayerLevelsProgressUtility levelProgressUtility = new PlayerLevelsProgressUtility(player.getName(), levelProgressData.getLevelsProgressData());
            levelProgressUtility.updateLevelInfo(levelCompleted, progressCompletedPercents);
            levelProgressData.setLevelsProgressData(levelProgressUtility.getLevelsData());
            levelProgressData.setLevelsProgressRankingPoints(levelProgressUtility.getProgressPoinsInSinglePlayerMode());
            status = this.playerDAO.updatePlayerLeveProgressRecord(levelProgressData);


            //Update achievements
            PlayerGameProfile playerGameProfile = this.playerGameProfileDAO.getPlayerGameProfile(player.getId());
            String achId = "403";
            final int levelsCompleted = 7;
            final int percentsToAchieveAtEachLevel = 100;
            if ((playerGameProfile.getAchievementsList() == null) || ("".equals(playerGameProfile.getAchievementsList()))) {
                if (levelProgressUtility.isLevelsCompletedWithReqPercent(levelsCompleted, percentsToAchieveAtEachLevel)) {
                    String achievemnets = playerGameProfile.getAchievementsList();
                    achievemnets = achId;
                    playerGameProfile.setAchievementsList(achievemnets);
                    Achievement achmnt = AchievementsConfiguration.getInstance().getAchievementForId(achId);
                    playerGameProfile.setCoinsBalance(playerGameProfile.getCoinsBalance() + achmnt.getAwardingCoins());
                    this.playerGameProfileDAO.updatePlayerGameProfile(playerGameProfile);
                }
            } else {
                if ((playerGameProfile.getAchievementsList() != null) && (!playerGameProfile.getAchievementsList().contains(achId))) {
                    if (levelProgressUtility.isLevelsCompletedWithReqPercent(levelsCompleted, percentsToAchieveAtEachLevel)) {
                        String achievemnets = playerGameProfile.getAchievementsList();
                        achievemnets += ";" + achId;
                        playerGameProfile.setAchievementsList(achievemnets);
                        Achievement achmnt = AchievementsConfiguration.getInstance().getAchievementForId(achId);
                        playerGameProfile.setCoinsBalance(playerGameProfile.getCoinsBalance() + achmnt.getAwardingCoins());
                        this.playerGameProfileDAO.updatePlayerGameProfile(playerGameProfile);
                    }
                }
            }


            return status;

        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return status;
    }

    public LevelsProgress getPlayerLevelProgress(int playerId) {
        try {
            return this.playerDAO.getPlayerLevelProgress(playerId);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public String getPlayerLevelProgressinXML(int playerId) {
        try {
            Player player = this.playerDAO.getPlayerById(playerId);
            LevelsProgress levelData = this.playerDAO.getPlayerLevelProgress(playerId);
            if (levelData != null) {
                PlayerLevelsProgressUtility levelProgressUtility = new PlayerLevelsProgressUtility(player.getName(), levelData.getLevelsProgressData());
                return levelProgressUtility.getXMLOutput();
            } else {
                return ConfigParams.NO_DATA_AVAILABLE_WS;
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            return ConfigParams.SERVER_APP_ERROR_WS;
        }
    }

    public ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> getPlayersListWithGameDataAndStatistics(ArrayList<Integer> playerIds) {
        return this.playerDAO.getPlayersWithGameProfAndStatisticsSortedByScores(playerIds);
    }

    public PlayerWithGameProfAndStatisticsAndChallengeData getPlayerListWithGameDataAndStatistics(int playerId) {
        return this.playerDAO.getPlayerWithGameProfle(playerId);
    }
    
    public ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> getPlayersListWithOnlinePlayersNotificationEnabled(){
        return this.playerDAO.getPlayersListWithGameProfleWithOnlinePlayersNotificationEnabled();
    }

    public ArrayList<PlayerWithPurchaseData> getPlayersWithPurchaseList(int maxNumOfRecords) {
        return this.purchaseTransactionDAO.getLatestTransactionsList(maxNumOfRecords);
    }
    
    public int deleteTansaction(int transactionId){
        return this.purchaseTransactionDAO.deleteTransaction(transactionId);
    }

    public Map<Integer, String> getFacebookIdentsForUsers(ArrayList<Integer> playerIds) {
        return this.facebookIdentityDAO.getFbIdentitiesForUSers(playerIds);
    }

    public ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> getTopPlayersData(int pageNumber, int numOnPage) {
        ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> topPlayers = null;

        ArrayList<Integer> playerIds = this.playerDAO.playerIdsSortedByMultiplayerScores();
        //requsted page that has no items
        if (((pageNumber * numOnPage) - numOnPage + 1) > playerIds.size()) {
            return null;
        }

        topPlayers = new ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData>();
        int startIndex = (pageNumber * numOnPage) - numOnPage;
        int endIndex = pageNumber * numOnPage - 1;
        //correct index for last page in listing
        if ((((int) (endIndex + 1) / playerIds.size())) == 1) {
            int correction = endIndex + 1 - playerIds.size();
            endIndex = endIndex - correction;
        }

        //in case there are less items that requested per page - just init last index with number of records
        if (numOnPage > playerIds.size()) {
            endIndex = playerIds.size() - 1;
        }


        //create players IDs list for requested page
        ArrayList<Integer> playerIdsForPage = new ArrayList<Integer>();
        for (int k = startIndex; k < (endIndex + 1); k++) {
            playerIdsForPage.add(playerIds.get(k));
        }


        topPlayers = this.playerDAO.getPlayersWithGameProfAndStatisticsSortedByScores(playerIdsForPage);

        Map<Integer, String> fbIdentities = this.facebookIdentityDAO.getFbIdentitiesForUSers(playerIdsForPage);

        for (int k = 0; k < topPlayers.size(); k++) {
            String fbIdentForPlayer = (String) fbIdentities.get(topPlayers.get(k).getPlayer().getId());
            if (fbIdentForPlayer != null) {
                topPlayers.get(k).setFacebookId(fbIdentForPlayer);
            }
        }



        //trick to get up round of division i.e. 3.2->4
        int numOfPagesToDisplay = (playerIds.size() + numOnPage - 1) / numOnPage;
        PlayerWithGameProfAndStatisticsAndChallengeData.setNumOfPages(numOfPagesToDisplay);

        return topPlayers;
    }

    public ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> getTopPlayersDataInSinglePlayerMode(int pageNumber, int numOnPage) {
        ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> topPlayers = null;

        ArrayList<Integer> playerIds = this.playerDAO.getPlayerIdsSortedByPointsInSinglePlayerMode();

        //requsted page that has no items
        if (((pageNumber * numOnPage) - numOnPage + 1) > playerIds.size()) {
            return null;
        }

        topPlayers = new ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData>();
        int startIndex = (pageNumber * numOnPage) - numOnPage;
        int endIndex = pageNumber * numOnPage - 1;
        //correct index for last page in listing
        if ((((int) (endIndex + 1) / playerIds.size())) == 1) {
            int correction = endIndex + 1 - playerIds.size();
            endIndex = endIndex - correction;
        }

        //in case there are less items that requested per page - just init last index with number of records
        if (numOnPage > playerIds.size()) {
            endIndex = playerIds.size() - 1;
        }


        //create players IDs list for requested page
        ArrayList<Integer> playerIdsForPage = new ArrayList<Integer>();
        for (int k = startIndex; k < (endIndex + 1); k++) {
            playerIdsForPage.add(playerIds.get(k));
        }


        topPlayers = this.playerDAO.getPlayersWithGameProfAndStatisticsSortedBySinglePlayerPoints(playerIdsForPage);

        Map<Integer, String> fbIdentities = this.facebookIdentityDAO.getFbIdentitiesForUSers(playerIdsForPage);
        for (int k = 0; k < topPlayers.size(); k++) {
            String fbIdentForPlayer = (String) fbIdentities.get(topPlayers.get(k).getPlayer().getId());
            if (fbIdentForPlayer != null) {
                topPlayers.get(k).setFacebookId(fbIdentForPlayer);
            }
        }

        //trick to get round of division i.e. 3.2->4
        int numOfPagesToDisplay = (playerIds.size() + numOnPage - 1) / numOnPage;
        PlayerWithGameProfAndStatisticsAndChallengeData.setNumOfPages(numOfPagesToDisplay);

        return topPlayers;
    }

    public ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> getPlayersWithGameProfAndChallengeData(List<ScoresRankingEntry> scoresRankingList, int numberOfEntries) {
        int maxNumOfRecords = 0;
        if (numberOfEntries > 0) {
            maxNumOfRecords = numberOfEntries;
        } else {
            maxNumOfRecords = scoresRankingList.size();
        }
        ArrayList<Integer> playerIds = new ArrayList<Integer>();
        for (int k = 0; k < maxNumOfRecords; k++) {
            playerIds.add(scoresRankingList.get(k).getPlayerId());
        }

        ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> players = this.playerDAO.getPlayersWithGameProfAndStatAndWeekChallengeData(playerIds);

        Map<Integer, String> fbIdentities = this.facebookIdentityDAO.getFbIdentitiesForUSers(playerIds);
        for (int k = 0; k < players.size(); k++) {
            String fbIdentForPlayer = (String) fbIdentities.get(players.get(k).getPlayer().getId());
            if (fbIdentForPlayer != null) {
                players.get(k).setFacebookId(fbIdentForPlayer);
            }
        }

        return players;
    }

    public ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> getPlayersListWithGameProfiles(int maxNumberOfRecords) {
        ArrayList<PlayerWithGameProfAndStatisticsAndChallengeData> playersList = this.playerDAO.getPlayersWithGameProfile(maxNumberOfRecords);

        return playersList;
    }

    public int savePlayerPurchaseRecord(PurchaseTransactionData purchData) {
        try {
            return this.purchaseTransactionDAO.createTransactionRecord(purchData);
        } catch (Exception ex) {
            ex.printStackTrace();
            return 0;
        }
    }

    public String getFbId(int playerId) {
        return this.facebookIdentityDAO.getFbIdForPlayer(playerId);
    }

    public int createFbIdentityInGame(int playerId, String facebookId) {
        return this.facebookIdentityDAO.createFbIdentity(playerId, facebookId);
    }

    public int removeFbIdentityInGame(int playerId) {
        return this.facebookIdentityDAO.removeFbIdentity(playerId);
    }

    public int getPlayerIdByFbID(String facebookId) {
        return this.facebookIdentityDAO.getPlayerIdForFbId(facebookId);
    }

    public ArrayList<Integer> getPlayersIDsForFacebookUsers(ArrayList<User> facebookUsers) {
        return this.facebookIdentityDAO.getPlayerIdsForFacebookUSers(facebookUsers);
    }

    public PlayerDAO getPlayerDAO() {
        return playerDAO;
    }

    public void setPlayerDAO(PlayerDAO playerDAO) {
        this.playerDAO = playerDAO;
    }

    public SecCodeDAO getSecCodeDAO() {
        return secCodeDAO;
    }

    public void setSecCodeDAO(SecCodeDAO secCodeDAO) {
        this.secCodeDAO = secCodeDAO;
    }

    public PlayerGameProfileDAO getPlayerGameProfileDAO() {
        return playerGameProfileDAO;
    }

    public void setPlayerGameProfileDAO(PlayerGameProfileDAO playerGameProfileDAO) {
        this.playerGameProfileDAO = playerGameProfileDAO;
    }

    public PlayerGameStatisticsDAO getPlayerGameStatisticsDAO() {
        return playerGameStatisticsDAO;
    }

    public void setPlayerGameStatisticsDAO(PlayerGameStatisticsDAO playerGameStatisticsDAO) {
        this.playerGameStatisticsDAO = playerGameStatisticsDAO;
    }

    public FacebookIdentityDAO getFacebookIdentityDAO() {
        return facebookIdentityDAO;
    }

    public void setFacebookIdentityDAO(FacebookIdentityDAO facebookIdentityDAO) {
        this.facebookIdentityDAO = facebookIdentityDAO;
    }

    public PurchaseTransactionDAO getPurchaseTransactionDAO() {
        return purchaseTransactionDAO;
    }

    public void setPurchaseTransactionDAO(PurchaseTransactionDAO purchaseTransactionDAO) {
        this.purchaseTransactionDAO = purchaseTransactionDAO;
    }
}
